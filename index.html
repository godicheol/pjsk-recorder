<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index.html</title>
    <link href="./style.css" rel="stylesheet" type="text/css" />
    <!-- <link href="./src/jquery-ui/jquery-ui.min.css" rel="stylesheet" type="text/css" /> -->
    <link href="./src/tabulator/css/tabulator_simple.min.css" rel="stylesheet" type="text/css" />
    <link href="./src/jquery-select-areas/resources/jquery.selectareas.css" media="screen" rel="stylesheet" type="text/css" />
    <style>
        *, *::after, *::before{
            font-family: Arial, Helvetica, sans-serif;
        }
        html{
            font-size: 14px;
            margin: 0;
            padding: 0;
        }
        body{
            margin: 0;
            padding: 8px;
        }
        #selection-wrapper img{
            width: 100%;
            height: auto;
        }
        #manual-wrapper{
            display: flex;
            height: 50vh;
            flex-direction: column;
            align-items: center;
            align-content: center;
            justify-content: center;
        }
        #manual-helps{
            display: flex;
            flex-direction: row;
            align-content: center;
            justify-content: center;
        }
        #manual-helps li::marker{
            color: black !important;
        }

        #manual-help-1.unselected li.unselected,
        #manual-help-1.unselected li.unselected::marker,
        #manual-help-2.unselected li,
        #manual-help-2.unselected li::marker{
            color: #ccc !important;
        }

    </style>
</head>

<body>
    <!-- header -->

    <div class="fw-9 fs-12 fc-15 bc-0 ta-c py-12" style="margin: -8px -8px 0 -8px;">
        Project Sekai Recorder
    </div>

    <!-- init container -->
    <div id="init-container">
        <h3>Initialization</h3>
        <ul>
            <li class="mb-8">
                <button id="manual-button" type="button">Manual</button>
            </li>
            <li>
                <input id="upload-csv-input" type="file" accept="text/csv">
            </li>
        </ul>
    </div>

    <!-- manual container -->
    <div id="manual-container" style="display: none;">
        <div id="manual-wrapper">
            <div class="ta-c">
                <div id="manual-progress" class="mb-4">1 / 2</div>
                <div id="manual-title" class="fs-12 mb-4">TEST</div>
                <div id="manual-sub-title">TEST</div>
            </div>
            <div id="manual-helps" class="mt-12">
                <div>
                    <ol id="manual-help-1" class="lh-6 my-0">
                        <li style="color: purple">MASTER</li>
                        <li style="color: red;">EXPERT</li>
                        <li style="color: orange;">HARD</li>
                        <li style="color: steelblue;">NORMAL</li>
                        <li style="color: olivedrab;">EASY</li>
                    </ol>
                </div>
                <div>
                    <ol id="manual-help-2" class="lh-6 my-0 unselected">
                        <li>ALL PERFECT</li>
                        <li>FULL COMBO</li>
                        <li>LIVE CLEAR</li>
                    </ol>
                </div>
            </div>
            <div class="mt-12 fc-7 fs-6">
                Pass "Space bar"
                Cancel "ESC"
            </div>
        </div>
    </div>

    <!-- records -->
    <div id="record-container" style="display: none;">
        <h3>
            Records
        </h3>
        
        <div class="mb-8">
            <button id="reset-button">Reset filter</button>
            <button id="download-button" type="button">Download</button>
        </div>

        <div id="record-table"></div>

        <!-- addition container -->
        <div id="addition-container">
            <div>
                <h3>Addition</h3>
                <!-- selection buttons -->
                <div class="mb-12">
                    <input id="upload-images-input" type="file" accept="image/*" multiple>
                    <button id="selection-read-button" type="button">Read</button>
                    <button id="selection-save-button" type="button">Save</button>
                </div>
            </div>

            <!-- selection -->
            <div id="selection-container">
                <div id="selection-wrapper"></div>
            </div>

            <!-- selection result -->
            <div class="my-12">
                <div id="selection-result-table"></div>
            </div>
        </div>

        <!-- chart -->
        <div id="chart-container" class="mb-8">
                <h3>Chart</h3>
                <!-- buttons -->
                <div>
                    <!-- chart type -->
                    <select id="chart-draw-type">
                        <option value="play-count">Play Count</option>
                        <option value="play-count-acc">Accumulated Play Count</option>
                        <option value="completeness">Completeness</option>
                        <option value="clear-count">Cleared Music Count</option>
                        <option value="clear-condition-count">Cleared Coundition Count</option>
                        <option value="combo-count">Combo Count</option>
                        <option value="condition-count">Condition Count</option>
                        <option value="condition-count-acc">Accumulated Condition Count</option>
                    </select>
                    <button id="chart-draw-button" type="button">Draw</button>
                </div>
                <div id="chart-wrapper" class="fs-0" style="max-height: 70vh;">
                    <canvas id="chart-canvas" width="0" height="0"></canvas>
                </div>
            </div>
            
        </div>
    </div>

    <!-- footer -->
    <div class="fc-15 bc-0 ta-r px-12 py-12" style="margin: 0 -8px -8px -8px;">
        <div class="f-l">
            <span>Last published:</span>
            <span id="last-published-music-title"></span>
        </div>
        <div class="f-r">
            <a class="fc-15" href="https://github.com/godicheol/pjsk-recorder/">Git</a>
        </div>
        <div class="f-n"></div>
    </div>

    <!-- js -->
    <script src="./src/tesseract.min.js"></script>
    <script src="./src/tabulator/js/tabulator.min.js"></script>
    <script src="./src/jquery.min.js"></script>
    <!-- <script src="./src/jquery-ui/jquery-ui.min.js"></script> -->
    <script src="./src/jquery-select-areas/jquery.selectareas.min.js"></script>
    <script src="./src/chartjs/chart.umd.js"></script>
    <!-- <script src="./src/chartjs-plugin-datalabels/chartjs-plugin-datalabels.min.js"></script> -->
    <script src="./src/csv.min.js"></script>
    <script src="./src/javascript-string.js"></script>
    <script src="./src/musics.js"></script> 
    <script src="./src/musics-kr.js"></script> 
    <script src="./src/musicDifficulties.js"></script>
    <script>
        if (!musics) {
            alert("Musics not found");
        }
        if (!musicDifficulties) {
            alert("MusicDifficulties not found");
        }

        // tesseract
        const { createWorker, PSM } = Tesseract;

        const initContainer = document.querySelector("#init-container");
        const manualButton = document.querySelector("#manual-button");
        const manualProgress = document.querySelector("#manual-progress");
        const manualTitle = document.querySelector("#manual-title");
        const manualSubTitle = document.querySelector("#manual-sub-title");
        const manualHelp1 = document.querySelector("#manual-help-1");
        const manualHelp2 = document.querySelector("#manual-help-2");
        const manualContainer = document.querySelector("#manual-container");
        const manualWrapper = document.querySelector("#manual-wrapper");
        const uploadImagesInput = document.querySelector("#upload-images-input");
        const uploadCSVInput = document.querySelector("#upload-csv-input");
        const additionContainer = document.querySelector("#addition-container");
        const selectionContainer = document.querySelector("#selection-container");
        const selectionWrapper = document.querySelector("#selection-wrapper");
        const selectionButtons = document.querySelector("#selection-buttons");
        const selectionReadButton = document.querySelector("#selection-read-button");
        const selectionSaveButton = document.querySelector("#selection-save-button");
        const selectionResultTable = document.querySelector("#selection-result-table");
        const recordContainer = document.querySelector("#record-container");
        const recordTable = document.querySelector("#record-table");
        const resetButton = document.querySelector("#reset-button");
        const downloadButton = document.querySelector("#download-button");
        
        const TITLE_CHARSET = getTitleCharSet();
        const SCORE_CHARSET = "0123456789";
        const DIFF_CHARSET = "ADEHLMNOPRSTXY";
        const TIME_DIFF = 9 * 60 * 60 * 1000; // kr UTC +0900

        let isInitialized = false;
        let inProgress = false;
        let uploadedFiles = [];
        let selection = null;
        let selectionResult = [];
        let selectionTabulator = null;
        let recordTabulator = null;

        try {
            const lastMusic = getLastPublishedMusic();
            document.querySelector("#last-published-music-title").innerHTML = lastMusic.title;
        } catch(err) {
            console.error(err);
        }

        function getNow() {
            const now = new Date();
            const utc = now.getTime() + now.getTimezoneOffset() * 60 * 1000;
            return new Date(utc + TIME_DIFF);
        }

        function parseISOLocal(s) {
            var b = s.split(/\D/);
            return new Date(b[0],b[1]-1,b[2]);
        }

        function setDateFormat(date) {
            return date.getFullYear() +
                '/' + ( (date.getMonth()+1) < 9 ? "0" + (date.getMonth()+1) : (date.getMonth()+1) ) +
                '/' + ( (date.getDate()) < 9 ? "0" + (date.getDate()) : (date.getDate()) );
        }

        function startEvent() {
            if (inProgress) {
                throw new Error("Already in progress.");
            }
            inProgress = true;
        }
        function endEvent() {
            inProgress = false;
        }
        function getScale(aspectRatio, type) {
            const _ = {
                // tested by iPhone12
                // aspect ratio 2.16
                mobile: {
                    title: {
                        x: 395 / 2532,
                        y: 0 / 1170,
                        w: 960 / 2532,
                        h: 75 / 1170,
                    },
                    difficulty: {
                        x: 406 / 2532,
                        y: 83 / 1170,
                        w: 195 / 2532,
                        h: 54 / 1170,
                    },
                    score: {
                        x: 300 / 2532,
                        y: 280 / 1170,
                        w: 616 / 2532,
                        h: 178 / 1170,
                    },
                    combo: {
                        x: 440 / 2532,
                        y: 670 / 1170,
                        w: 520 / 2532,
                        h: 300 / 1170,
                    },
                    perfect: {
                        x: 1170 / 2532,
                        y: 676 / 1170,
                        w: 160 / 2532,
                        h: 60 / 1170,
                    },
                    great: {
                        x: 1170 / 2532,
                        y: 734 / 1170,
                        w: 160 / 2532,
                        h: 60 / 1170,
                    },
                    good: {
                        x: 1170 / 2532,
                        y: 792 / 1170,
                        w: 160 / 2532,
                        h: 60 / 1170,
                    },
                    bad: {
                        x: 1170 / 2532,
                        y: 846 / 1170,
                        w: 160 / 2532,
                        h: 60 / 1170,
                    },
                    miss: {
                        x: 1170 / 2532,
                        y: 897 / 1170,
                        w: 160 / 2532,
                        h: 60 / 1170,
                    }
                },
                // aspect ratio < 1.8
                tablet: {
                    title: {
                        x: 70/850,
                        y: 0/637,
                        w: 391/850,
                        h: 33/637,
                    },
                    difficulty: {
                        x: 75/850,
                        y: 35/637,
                        w: 77/850,
                        h: 21/637,
                    },
                    score: {
                        x: 28/850,
                        y: 202/637,
                        w: 310/850,
                        h: 72/637,
                    },
                    combo: {
                        x: 91/850,
                        y: 364/637,
                        w: 205/850,
                        h: 119/637,
                    },
                    perfect: {
                        x: 388/850,
                        y: 364/637,
                        w: 60/850,
                        h: 23/637,
                    },
                    great: {
                        x: 388/850,
                        y: 387/637,
                        w: 60/850,
                        h: 23/637,
                    },
                    good: {
                        x: 388/850,
                        y: 410/637,
                        w: 60/850,
                        h: 23/637,
                    },
                    bad: {
                        x: 388/850,
                        y: 433/637,
                        w: 60/850,
                        h: 23/637,
                    },
                    miss: {
                        x: 388/850,
                        y: 456/637,
                        w: 60/850,
                        h: 23/637,
                    },
                }
            }

            if (aspectRatio > 1.8) {
                return _.mobile[type];
            } else {
                return _.tablet[type];
            }
        }
        function getTitleCharSet() {
            return musics.map(function(item) {
                return item.title;
            }).reduce(function(prev, curr) {
                return prev + curr.split("").reduce(function(_prev, _curr) {
                    return prev.indexOf(_curr) < 0 ? _prev + _curr : _prev;
                }, "");
            }, "")
        }
        async function readText(image, pos, charset, mode) {
            const worker = await createWorker();
            await worker.loadLanguage('eng+jpn');
            await worker.initialize('eng+jpn');
            if (charset) {
                await worker.setParameters({
                    tessedit_char_whitelist: charset
                });
            }
            const { data: { text } } = await worker.recognize(image, {
                rectangle: {
                    top: pos.y,
                    left: pos.x,
                    width: pos.width,
                    height: pos.height
                },
                tessedit_pageseg_mode: mode || PSM.SINGLE_BLOCK,
            });
            await worker.terminate();
            return text;
        }
        async function uploadImagesHandler(e) {
            const files = e.target.files;
            if (files.length < 1) {
                return false;
            }
            try {
                startEvent();
            } catch(err) {
                console.error(err);
                e.target.value = null;
                return false;
            }

            uploadedFiles = [];
            for (var i = 0; i < files.length; i++) {
                uploadedFiles.push(files[i]);
            }
            
            await renderSelection(uploadedFiles[0]);

            endEvent();

            e.target.value = null;
        }
        async function renderSelection(file) {
            selection = await loadImage(file);
            selectionWrapper.innerHTML = "";
            selectionWrapper.appendChild(selection);

            const r1 = getBoundingBox(selection, "title");
            const r2 = getBoundingBox(selection, "difficulty");
            const r3 = getBoundingBox(selection, "score");
            const r4 = getBoundingBox(selection, "combo");
            const r5 = getBoundingBox(selection, "perfect");
            const r6 = getBoundingBox(selection, "great");
            const r7 = getBoundingBox(selection, "good");
            const r8 = getBoundingBox(selection, "bad");
            const r9 = getBoundingBox(selection, "miss");

            $(selection).selectAreas({
                allowSelect: false,
                allowDelete: false,
                minSize: [10, 10],
                areas: [r1,r2,r3,r4,r5,r6,r7,r8,r9]
            });
        }
        async function loadImage(file) {
            return new Promise(async function(resolve, reject) {
                const img = document.createElement("img");
                img.onload = function() {
                    resolve(img);
                }
                img.onerror = function(err) {
                    reject(err);
                }
                img.src = URL.createObjectURL(file);
            });
        }
        function getBoundingBox(image, type) {
            const {width, height, naturalWidth, naturalHeight} = image;
            const aspectRatio = naturalWidth / naturalHeight;
            const scale = getScale(aspectRatio, type);
            return {
                x: width * scale.x,
                y: height * scale.y,
                width: width * scale.w,
                height: height * scale.h,
            }
        }
        function endSelection() {
            if (selection) {
                $(selection).selectAreas("destroy");
                selection = null;
            }
            selectionWrapper.innerHTML = "";
        }
        function getSelectedScales() {
            return $(selection).selectAreas("areas").map(function(item) {
                return {
                    x: item.x / selection.width,
                    y: item.y / selection.height,
                    width: item.width / selection.width,
                    height: item.height / selection.height
                };
            });
        }
        function getSelectedAreas(image, scales) {
            const areas = scales.map(function(item) {
                return {
                    x: image.naturalWidth * item.x,
                    y: image.naturalHeight * item.y,
                    width: image.naturalWidth * item.width,
                    height: image.naturalHeight * item.height
                };
            });

            return {
                title: areas[0],
                difficulty: areas[1],
                score: areas[2],
                combo: areas[3],
                perfect: areas[4],
                great: areas[5],
                good: areas[6],
                bad: areas[7],
                miss: areas[8],
            }
        }
        async function readImage(file, scales) {
            const image = await loadImage(file);
            const areas = getSelectedAreas(image, scales);
            const title = (await readText(image, areas.title, TITLE_CHARSET)).replace(/\s/g, "");
            console.log("Title:", title);
            const difficulty = getDifficulty(await readText(image, areas.difficulty, DIFF_CHARSET));
            console.log("Difficulty:", difficulty);
            const score = parseInt(await readText(image, areas.score, SCORE_CHARSET));
            console.log("Score:", score);
            const combo = parseInt(await readText(image, areas.combo, SCORE_CHARSET));
            console.log("Combo:", combo);
            const perfect = parseInt(await readText(image, areas.perfect, SCORE_CHARSET));
            console.log("Perfect:", perfect);
            const great = parseInt(await readText(image, areas.great, SCORE_CHARSET));
            console.log("Great:", great);
            const good = parseInt(await readText(image, areas.good, SCORE_CHARSET));
            console.log("Good:", good);
            const bad = parseInt(await readText(image, areas.bad, SCORE_CHARSET));
            console.log("Bad:", bad);
            const miss = parseInt(await readText(image, areas.miss, SCORE_CHARSET));
            console.log("Miss:", miss);
            return {
                title,
                difficulty,
                score,
                combo,
                perfect,
                great,
                good,
                bad,
                miss,
            }
        }
        async function readHandler() {
            if (uploadedFiles.length < 1) {
                console.error("Files not found");
                return false;
            }
            if (!selection) {
                console.error("Selection not found");
                return false;
            }

            startEvent();
            selectionReadButton.innerHTML = "Reading...";

            // get selected scales
            const scales = getSelectedScales();

            // destroy selection
            endSelection();
            createSelectionTabulator();

            for (let i = 0; i < uploadedFiles.length; i++) {
                const file = uploadedFiles[i];
                const data = await readImage(file, scales);
                const music = getMusic(data.title);
                const musicDiff = getMusicDiff(music, data.difficulty);
                const now = new Date().getTime();

                const record = {
                    mid: music.id,
                    mdid: musicDiff.id,
                    score: data.score,
                    combo: data.combo,
                    perfect: data.perfect,
                    great: data.great,
                    good: data.good,
                    bad: data.bad,
                    miss: data.miss,
                    createdAt: now,
                    updatedAt: now,
                }
                const tableData = convertToData(record);
                selectionTabulator.addData([tableData]);
            }

            selectionReadButton.innerHTML = "Read";

            endEvent();
        }
        function convertToData(data) {
            const music = musics.find(function(item) {
                return item.id === data.mid;
            });
            if (!music) {
                console.error("Music not found");
                return false;
            }
            const musicDifficulty = musicDifficulties.find(function(item) {
                return item.id === data.mdid;
            });
            if (!musicDifficulty) {
                console.error("Music difficulty not found");
                return false;
            }
            const condition = getCondition(musicDifficulty, data);
            return {
                seq: music.seq,
                mid: music.id,
                mdid: musicDifficulty.id,
                title: music.title,
                titleKr: getKoreanTitle(music.id),
                creator: music.creator,
                composer: music.composer,
                difficulty: musicDifficulty.musicDifficulty.toUpperCase(),
                playLevel: musicDifficulty.playLevel,
                totalNoteCount: musicDifficulty.totalNoteCount,
                condition: condition,
                score: data.score,
                combo: data.combo,
                perfect: data.perfect,
                great: data.great,
                good: data.good,
                bad: data.bad,
                miss: data.miss,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt,
                timestamp: new Date(data.createdAt)
            }
        }
        function convertToRecord(data) {
            return {
                mid: data.mid,
                mdid: data.mdid,
                score: data.score,
                combo: data.combo,
                perfect: data.perfect,
                great: data.great,
                good: data.good,
                bad: data.bad,
                miss: data.miss,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt,
            }
        }
        function getAccuracy(a, b) {
            return jsString.parse(a, b).reduce(function(prev, curr) {
                return curr.isMatched ? prev + (curr.to[1] - curr.to[0]) : prev;
            }, 0) / Math.max(a.length, b.length);
        }
        function getMusic(title) {
            let music;
            let acc = 0;
            musics.forEach(function(item) {
                const _acc = getAccuracy(item.title.replace(/\s/g, ""), title);
                if (acc < _acc) {
                    acc = _acc;
                    music = item;
                }
            });
            return music;
        }
        function getMusicDiff(music, difficulty) {
            return musicDifficulties.find(function(item) {
                return item.musicId === music.id && item.musicDifficulty === difficulty.toLowerCase();
            });
        }
        function getDifficulty(diff) {
            const arr = ["MASTER", "EXPERT", "HARD", "NORMAL", "EASY"];
            let difficulty;
            let acc = 0;
            arr.forEach(function(item) {
                const _acc = getAccuracy(item, diff);
                if (acc < _acc) {
                    acc = _acc;
                    difficulty = item;
                }
            });
            return difficulty;
        }

        function getLastPublishedMusic() {
            return musics.reduce(function(prev, curr) {
                if (prev.publishedAt < curr.publishedAt) {
                    prev = curr;
                }
                return prev;
            }, {
                publishedAt: 0
            });
        }
        
        // 
        // selection
        // 

        function getCondition(musicDiff, data) {
            const {combo, perfect, great, good, bad, miss} = data;
            const totalNoteCount = musicDiff.totalNoteCount;
            if (!musicDiff) {
                return "NOT FOUND";
            } else if (combo > totalNoteCount) {
                return "COMBO ERROR";
            } else if (good+bad+miss === 0 && combo < perfect+great) {
                return "COMBO ERROR";
            } else if (combo > perfect+great) {
                return "COMBO ERROR";
            } else if (perfect+great+good+bad+miss !== totalNoteCount) {
                return "COUNT ERROR";
            } else if (perfect === totalNoteCount) {
                return "ALL PERFECT";
            } else if (combo === totalNoteCount) {
                return "FULL COMBO";
            } else {
                return "LIVE CLEAR";
            }
        }
        function isValidData(data) {
            const {mid, mdid, combo, perfect, great, good, bad, miss} = data;
            const music = musics.find(function(item) {
                return item.id === mid;
            });
            const musicDiff = musicDifficulties.find(function(item) {
                return item.id === mdid;
            });
            if (!music) {
                return false;
            }
            if (!musicDiff) {
                return false;
            }
            const totalNoteCount = musicDiff.totalNoteCount;
            if (!musicDiff) {
                return false;
            } else if (combo > totalNoteCount) {
                return false;
            } else if (good+bad+miss === 0 && combo < perfect+great) {
                return false;
            } else if (combo > perfect+great) {
                return false
            } else if (perfect+great+good+bad+miss !== totalNoteCount) {
                return false;
            } else {
                return true;
            }
        }
        function getKoreanTitle(id) {
            if (!musicsKr) {
                return "";
            }
            const music = musicsKr.find(function(item) {
                return item.id === id;
            });
            return music && music.infos[0] ? music.infos[0].title : "";
        }
        function editTitleHandler(cell) {
            const value = parseInt(cell.getValue());
            const row = cell.getRow();
            const data = row.getData();
            const music = musics.find(function(item) {
                return item.id === value;
            });
            if (!music) {
                console.error("Music not found");
                return false;
            }
            const musicDifficulty = getMusicDiff(music, data.difficulty);
            if (!musicDifficulty) {
                console.error("Music difficulty not found");
                return false;
            }

            const condition = getCondition(musicDifficulty, data);

            row.update({
                mid: music.id,
                mdid: musicDifficulty.id,
                title: music.title,
                titleKr: getKoreanTitle(music.id),
                creator: music.creator,
                condition: condition,
                playLevel: musicDifficulty.playLevel,
                totalNoteCount: musicDifficulty.totalNoteCount,
                updatedAt: new Date().getTime()
            });
        }
        function editDifficultyHandler(cell) {
            const value = cell.getValue();
            const row = cell.getRow();
            const data = row.getData();
            const musicDifficulty = getMusicDiff({id: data.mid}, value);
            if (!musicDifficulty) {
                console.error("Music difficulty not found");
                return false;
            }

            const condition = getCondition(musicDifficulty, data);

            row.update({
                mdid: musicDifficulty.id,
                condition: condition,
                playLevel: musicDifficulty.playLevel,
                totalNoteCount: musicDifficulty.totalNoteCount,
                updatedAt: new Date().getTime()
            });
        }
        function editComboHandler(cell) {
            const value = cell.getValue();
            const row = cell.getRow();
            const data = row.getData();
            const musicDifficulty = getMusicDiff({id: data.mid}, data.difficulty);
            if (!musicDifficulty) {
                console.error("Music difficulty not found");
                return false;
            }
            const condition = getCondition(musicDifficulty, data);

            row.update({
                condition: condition,
                updatedAt: new Date().getTime()
            });
        }
        function editHandler() {
            const value = cell.getValue();
            const row = cell.getRow();
            row.update({
                updatedAt: new Date().getTime()
            });
        }
        function getMusicTitleForEditorParams() {
            return musics.sort(function(a,b) {
                return a.seq - b.seq;
            }).reduce(function(prev, curr) {
                prev[curr.id] = curr.title;
                return prev;
            }, {});
        }
        function getMusicTitleForFilterParams() {
            return musics.sort(function(a,b) {
                return a.seq - b.seq;
            }).reduce(function(prev, curr) {
                prev[curr.title] = curr.title;
                return prev;
            }, {});
        }
        function createSelectionTabulator() {
            selectionTabulator = new Tabulator("#selection-result-table", {
                layout: "fitDataFill",
                renderHorizontal:"virtual",
                columns: [
                    {title: "Title", field: "title", editor: "list", editorParams: {
                        values: getMusicTitleForEditorParams()
                    }, cellEdited: editTitleHandler, headerSort: false},
                    {title: "제목", field: "titleKr", headerSort: false},
                    {title: "Artist", field: "composer", headerSort: false},
                    {title: "Difficulty", field: "difficulty", editor: "list", editorParams: {
                        values: {
                            "MASTER": "MASTER",
                            "EXPERT": "EXPERT",
                            "HARD": "HARD",
                            "NORMAL": "NORMAL",
                            "EASY": "EASY",
                        }
                    }, cellEdited: editDifficultyHandler, headerSort: false},
                    {title: "Level", field: "playLevel", headerSort: false},
                    {title: "Notes", field: "totalNoteCount", headerSort: false},
                    {title: "Condition", field: "condition", headerSort: false, formatter: conditionFormatter},
                    {title: "Score", field: "score", editor:"number", cellEdited: editHandler, headerSort: false},
                    {title: "Combo", field: "combo", editor:"number", cellEdited: editComboHandler, headerSort: false},
                    {title: "Perfect", field: "perfect", editor:"number", cellEdited: editComboHandler, headerSort: false},
                    {title: "Great", field: "great", editor:"number", cellEdited: editComboHandler, headerSort: false},
                    {title: "Good", field: "good", editor:"number", cellEdited: editComboHandler, headerSort: false},
                    {title: "Bad", field: "bad", editor:"number", cellEdited: editComboHandler, headerSort: false},
                    {title: "Miss", field: "miss", editor:"number", cellEdited: editComboHandler, headerSort: false},
                ]
            });
        }

        function destroySelectionTabulator() {
            if (selectionTabulator) {
                selectionTabulator.destroy();
            }
        }

        // 
        // render records table
        // 

        function conditionFormatter(cell, formatterParams) {
            const value = cell.getValue();
            if (["ALL PERFECT", "FULL COMBO", "LIVE CLEAR"].indexOf(value) > -1) {
                cell.getRow().getElement().style.backgroundColor = "";
            } else {
                cell.getRow().getElement().style.backgroundColor = "#EE6666";
            }
            return value;
        }

        function renderRecordTable(data) {
            const _data = data.sort(function(a, b) {
                return a.createdAt - b.createdAt;
            }).map(function(item) {
                return convertToData(item);
            });
            //custom header filter
            var dateFilterEditor = function(cell, onRendered, success, cancel, editorParams){

                var container = $("<span></span>")
                //create and style input
                var start = $("<input type='date' placeholder='Start'/>");
                var end = $("<input type='date' placeholder='End'/>");

                container.append(start).append(end);

                var inputs = $("input", container);


                inputs.css({
                    "padding":"4px",
                    "width":"50%",
                    "box-sizing":"border-box",
                })
                .val(cell.getValue());

                function buildDateString(){
                    return {
                        start:start.val(),
                        end:end.val(),
                    };
                }

                //submit new value on blur
                inputs.on("change blur", function(e){
                    success(buildDateString());
                });

                //submit new value on enter
                inputs.on("keydown", function(e){
                    if(e.keyCode == 13){
                        success(buildDateString());
                    }

                    if(e.keyCode == 27){
                        cancel();
                    }
                });

                return container[0];
            }
            //custom filter function
            function dateFilterFunction(headerValue, rowValue, rowData, filterParams){
                //headerValue - the value of the header filter element
                //rowValue - the value of the column in this row
                //rowData - the data for the row being filtered
                //filterParams - params object passed to the headerFilterFuncParams property

                var start = parseISOLocal(headerValue.start);
                var end = parseISOLocal(headerValue.end);
                var value = new Date(rowValue).getTime();
                if(rowValue){
                    if (headerValue.start != ""){
                        if (headerValue.end != ""){
                            end.setDate(end.getDate() + 1);
                            return value >= start.getTime() && value <= end.getTime();
                        } else{
                            return value >= start.getTime();
                        }
                    } else {
                        if(headerValue.end != ""){
                            end.setDate(end.getDate() + 1);
                            return value <= end.getTime();
                        }
                    }
                }

                return false; //must return a boolean, true if it passes the filter.
            }
            var minMaxFilterEditor = function(cell, onRendered, success, cancel, editorParams){
                var end;
                var container = document.createElement("span");
                //create and style inputs
                var start = document.createElement("input");
                start.setAttribute("type", "number");
                start.setAttribute("placeholder", "Min");
                start.setAttribute("min", 0);
                start.setAttribute("max", 100);
                start.style.padding = "4px";
                start.style.width = "50%";
                start.style.boxSizing = "border-box";
                start.value = cell.getValue();
                function buildValues(){
                    success({
                        start:start.value,
                        end:end.value,
                    });
                }
                function keypress(e){
                    if(e.keyCode == 13){
                        buildValues();
                    }

                    if(e.keyCode == 27){
                        cancel();
                    }
                }
                end = start.cloneNode();
                end.setAttribute("placeholder", "Max");

                start.addEventListener("change", buildValues);
                start.addEventListener("blur", buildValues);
                start.addEventListener("keydown", keypress);
                end.addEventListener("change", buildValues);
                end.addEventListener("blur", buildValues);
                end.addEventListener("keydown", keypress);
                container.appendChild(start);
                container.appendChild(end);

                return container;
            }

            //custom max min filter function
            function minMaxFilterFunction(headerValue, rowValue, rowData, filterParams){
                //headerValue - the value of the header filter element
                //rowValue - the value of the column in this row
                //rowData - the data for the row being filtered
                //filterParams - params object passed to the headerFilterFuncParams property

                if(rowValue){
                    if(headerValue.start != ""){
                        if(headerValue.end != ""){
                            return rowValue >= headerValue.start && rowValue <= headerValue.end;
                        }else{
                            return rowValue >= headerValue.start;
                        }
                    }else{
                        if(headerValue.end != ""){
                            return rowValue <= headerValue.end;
                        }
                    }
                }

                return true; //must return a boolean, true if it passes the filter.
            }
        
            recordTabulator = new Tabulator("#record-table", {
                data: _data,
                height: "70vh",
                renderHorizontal:"virtual",
                layout: "fitDataFill",
                groupBy: function(__data) {
                    return setDateFormat(__data.timestamp);
                },
                columns: [
                    {title: "Title", field: "title", editor: "list", editorParams: {
                        values: getMusicTitleForEditorParams()
                    }, cellEdited: editTitleHandler, headerFilter: "input", headerSort: false},
                    {title: "제목", field: "titleKr", headerFilter: "input", headerSort: false},
                    {title: "Artist", field: "composer", headerFilter: "input", headerSort: false},
                    {title: "Difficulty", field: "difficulty", editor: "list", editorParams: {
                        values: {
                            "MASTER": "MASTER",
                            "EXPERT": "EXPERT",
                            "HARD": "HARD",
                            "NORMAL": "NORMAL",
                            "EASY": "EASY",
                        }
                    }, cellEdited: editDifficultyHandler, headerFilter: true, headerFilterParams: {
                        values: {
                            "MASTER": "MASTER",
                            "EXPERT": "EXPERT",
                            "HARD": "HARD",
                            "NORMAL": "NORMAL",
                            "EASY": "EASY",
                        }
                    }, headerSort: false},
                    {title: "Level", field: "playLevel", width: 128, headerFilter:minMaxFilterEditor, headerFilterFunc:minMaxFilterFunction, headerFilterLiveFilter:false, headerSort: false},
                    {title: "Notes", field: "totalNoteCount", headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Condition", field: "condition", headerFilter:"input", headerSort: false, formatter: conditionFormatter},
                    {title: "Score", field: "score", editor:"number", headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Combo", field: "combo", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Perfect", field: "perfect", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Great", field: "great", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Good", field: "good", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Bad", field: "bad", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Miss", field: "miss", editor:"number", cellEdited: editComboHandler, headerFilter:"number", headerFilterPlaceholder:"at least...", headerFilterFunc:">=", headerSort: false},
                    {title: "Time", field: "createdAt", headerFilter:dateFilterEditor, headerFilterFunc:dateFilterFunction, formatter: function(cell) {
                        return setDateFormat(new Date(cell.getValue()));
                    }, headerSort: false,},
                ]
            });
        }

        function clearRecordTableSorting() {
            if (recordTabulator) {
                recordTabulator.clearSort();
            }
        }

        function clearRecordTableFilter() {
            if (recordTabulator) {
                recordTabulator.clearFilter();
                recordTabulator.clearHeaderFilter();
            }
        }

        // 
        // manual initialize
        // 

        function getManualMusicList() {
            const __getDiff = function(id) {
                return ["master", "expert", "hard", "normal", "easy"].reduce(function(prev, curr) {
                    const diff = musicDifficulties.find(function(item) {
                        return item.musicId === id && item.musicDifficulty === curr
                    });
                    prev[curr] = {
                        id: diff.id,
                        totalNoteCount: diff.totalNoteCount,
                        playLevel: diff.playLevel
                    };
                    return prev;
                }, {});
            }
            return musics.map(function(item) {
                return {
                    id: item.id,
                    seq: item.seq,
                    title: item.title,
                    titleKr: getKoreanTitle(item.id),
                    artist: item.creator,
                    difficulties: __getDiff(item.id)
                }
            }).sort(function(a, b) {
                return a.seq - b.seq;
            });
        }

        function showManualContainer() {
            manualContainer.style.display = "";
        }
        function hideManualContainer() {
            manualContainer.style.display = "none";
        }

        function startManualInitialize() {
            if (isInitialized) {
                alert("Already initialized!");
                return false;
            }
            startEvent();
            showManualContainer();
            hideInitContainer();
            hideAdditionContainer();

            const list = getManualMusicList();
            let result = [];
            let l = list.length;
            let i = 0;
            let state = 0;
            let difficulty = 0;
            let condition = 0;

            function exec() {
                function renderTitle(title) {
                    manualTitle.innerHTML = title;
                }
                function renderSubTitle(title) {
                    if (title) {
                        manualSubTitle.innerHTML = title;
                    } else {
                        manualSubTitle.innerHTML = " ";
                    }
                }
                function renderProgress() {
                    manualProgress.innerHTML = (i+1) + " / " + l;
                }
                if (i < l) {
                    const item = list[i];
                    renderTitle(item.title);
                    renderSubTitle(item.titleKr);
                    renderProgress();
                } else {
                    // end
                    renderRecordTable(result);
                    showRecordContainer();
                    isInitialized = true;
                    destroy();
                    hideInitContainer();
                    showAdditionContainer();
                    console.log("End initialized");
                }
            }
            function saveRecord() {
                const music = list[i];
                const now = new Date().getTime();
                let record = {
                    mid: music.id,
                    mdid: null,
                    score: 0,
                    combo: 0,
                    perfect: 0,
                    great: 0,
                    good: 0,
                    bad: 0,
                    miss: 0,
                    createdAt: now,
                    updatedAt: now
                }
                let totalNoteCount;
                if (difficulty === 0) {
                    record.mdid = music.difficulties.master.id;
                    totalNoteCount = music.difficulties.master.totalNoteCount;
                } else if (difficulty === 1) {
                    record.mdid = music.difficulties.expert.id;
                    totalNoteCount = music.difficulties.expert.totalNoteCount;
                } else if (difficulty === 2) {
                    record.mdid = music.difficulties.hard.id;
                    totalNoteCount = music.difficulties.hard.totalNoteCount;
                } else if (difficulty === 3) {
                    record.mdid = music.difficulties.normal.id;
                    totalNoteCount = music.difficulties.normal.totalNoteCount;
                } else if (difficulty === 4) {
                    record.mdid = music.difficulties.easy.id;
                    totalNoteCount = music.difficulties.easy.totalNoteCount;
                }
                if (condition === 0) {
                    // AP
                    record.combo = totalNoteCount;
                    record.perfect = totalNoteCount;
                } else if (condition === 1) {
                    // FC
                    record.combo = totalNoteCount;
                    record.great = totalNoteCount;
                } else if (condition === 2) {
                    // LC
                    record.good = totalNoteCount;
                }
                result.push(record);
            }
            function prevMusic() {
                if (i > 0) {
                    if (result.length > 0 && list[i].title === result[result.length - 1].title) {
                        result.pop();
                    }
                    clearHighlight();
                    manualHelp2.classList.add("unselected");
                    state = 0
                    difficulty = 0;
                    condition = 0;
                    i--;
                    exec();
                } else {
                    console.error("First item of list");
                }
            }
            function passMusic() {
                clearHighlight();
                manualHelp2.classList.add("unselected");
                state = 0
                difficulty = 0;
                condition = 0;
                i++;
                exec();
            }
            function setHighlight(n) {
                const items = manualHelp1.children;
                for (var i = 0; i < items.length; i++) {
                    if (i === n) {
                        items[i].classList.add("selected");
                    } else {
                        items[i].classList.add("unselected");
                    }
                }
            }
            function clearHighlight() {
                const items = manualHelp1.children;
                for (var i = 0; i < items.length; i++) {
                    items[i].classList.remove("selected");
                    items[i].classList.remove("unselected");
                }
                manualHelp1.classList.remove("unselected");
                manualHelp2.classList.remove("unselected");
            }
            
            function selectItem(n) {
                if (state === 0) {
                    if (n < 0 || n > 4) {
                        return false;    
                    }
                    clearHighlight();
                    setHighlight(n)
                    difficulty = n;
                    state = 1;
                    manualHelp1.classList.add("unselected");
                } else {
                    if (n < 0 || n > 2) {
                        return false;    
                    }
                    clearHighlight();
                    condition = n;
                    state = 0;
                    saveRecord();
                    i++;
                    exec();
                    manualHelp2.classList.add("unselected");
                }
            }
            function keydownHandler(e) {
                const {key, keyCode, code, shiftKey } = e;
                // console.log(key, keyCode, code, shiftKey)

                if (keyCode === 27) {
                    // escape
                    e.preventDefault();
                    destroy();
                    showInitContainer();
                    showAdditionContainer();
                } else if (keyCode === 13) {
                    // enter
                    // e.preventDefault();
                    // passMusic();
                } else if (keyCode === 32) {
                    // spacebar
                    e.preventDefault();
                    passMusic();
                } else if (keyCode === 8) {
                    // backspace
                    e.preventDefault();
                    prevMusic();
                } else if (keyCode === 49) {
                    // 1
                    e.preventDefault();
                    selectItem(0);
                } else if (keyCode === 50) {
                    // 2
                    e.preventDefault();
                    selectItem(1);
                } else if (keyCode === 51) {
                    // 3
                    e.preventDefault();
                    selectItem(2);
                } else if (keyCode === 52) {
                    // 4
                    e.preventDefault();
                    selectItem(3);
                } else if (keyCode === 53) {
                    // 5
                    e.preventDefault();
                    selectItem(4);
                }
            };

            function destroy() {
                clearHighlight();
                hideManualContainer();
                document.removeEventListener("keydown", keydownHandler);
                endEvent();
            }

            exec();

            document.addEventListener("keydown", keydownHandler);
        }

        function saveHandler() {
            startEvent();
            if (selectionTabulator && recordTabulator) {
                const data = selectionTabulator.getData();

                // check
                for (const item of data) {
                    if (!isValidData(item)) {
                        alert("Invalid data found.");
                        endEvent();
                        return false;
                    }
                }

                recordTabulator.addData(data);
                destroySelectionTabulator();
            }
            endEvent();
        }

        function checkValidData(data) {
            const music = musics.find(function(item) {
                return item.id === data.mid;
            });
            if (!music) {
                console.error("Music not found");
                return false;
            }
            const musicDifficulty = musicDifficulties.find(function(item) {
                return item.id === data.mdid;
            });
            if (!musicDifficulty) {
                console.error("Music difficulty not found");
                return false;
            }

            const condition = getCondition(musicDifficulty, data);

            row.update({
                mid: music.id,
                mdid: musicDifficulty.id,
                title: music.title,
                titleKr: getKoreanTitle(music.id),
                creator: music.creator,
                condition: condition,
                playLevel: musicDifficulty.playLevel,
                totalNoteCount: musicDifficulty.totalNoteCount,
            });
        }

        function downloadHandler() {
            startEvent();
            if (recordTabulator) {
                const data = recordTabulator.getData().map(function(item) {
                    return convertToRecord(item);
                }).sort(function(a, b) {
                    if (a.createdAt !== b.createdAt) {
                        return a.createdAt - b.createdAt;
                    } else {
                        return a.seq - b.seq;
                    }
                });

                // check values
                for (const item of data) {
                    if (!isValidData(item)) {
                        alert("Invalid data found.");
                        endEvent();
                        return false;
                    }
                }

                downloadToCSV(data);
            }
            endEvent();
        }

        function showAdditionContainer() {
            additionContainer.style.display = "";
        }
        function hideAdditionContainer() {
            additionContainer.style.display = "none";
        }
        function showInitContainer() {
            initContainer.style.display = "";
        }
        function hideInitContainer() {
            initContainer.style.display = "none";
        }
        function showRecordContainer() {
            recordContainer.style.display = "";
        }

        function downloadToCSV(data) {
            var header = [
                "mid",
                "mdid",
                "score",
                "combo",
                "perfect",
                "great",
                "good",
                "bad",
                "miss",
                "createdAt",
                "updatedAt",
            ];
            var csv = new CSV(data, { header: header}).encode();
            var element = document.createElement('a');
            element.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv));
            element.setAttribute('download', "pjsk-recorder-"+Date.now());
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        async function uploadCSVHandler(e) {
            const file = e.target.files[0];
            if (!file) {
                return false;
            }

            const data = await readCSV(file);

            renderRecordTable(data);
            hideInitContainer();
            showRecordContainer();
        }

        function readCSV(file) {
            return new Promise(function(resolve, reject) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new CSV(e.target.result, {
                        header: true
                    }).parse();
                    resolve(data);
                }
                reader.onerror = function(err) {
                    reject(err);
                }
                reader.readAsText(file);
            });
        }

        function resetRecordTable() {
            clearRecordTableFilter();
            clearRecordTableSorting();
        }

        function resetHandler() {
            resetRecordTable();
        }

        uploadImagesInput.addEventListener("change", uploadImagesHandler);
        uploadCSVInput.addEventListener("change", uploadCSVHandler);
        selectionReadButton.addEventListener("click", readHandler);
        selectionSaveButton.addEventListener("click", saveHandler);
        manualButton.addEventListener("click", startManualInitialize);
        downloadButton.addEventListener("click", downloadHandler);
        resetButton.addEventListener("click", resetHandler);

        // 
        // chart
        //

        (async function() {
            const chartDrawType = document.querySelector("#chart-draw-type");
            const chartDrawButton = document.querySelector("#chart-draw-button");
            const chartWrapper = document.querySelector("#chart-wrapper");
            const chartCanvas = document.querySelector("#chart-canvas");

            // Chart.register(ChartDataLabels); // show label value

            // Chart.defaults.set('plugins.datalabels', {
            //     color: '#000000',
            //     clamp: true,
            //     align: "top"
            // });

            // $(function() {
            //     $( "#chart-wrapper" ).resizable({
            //         minWidth: 100,
            //         minHeight: 100,
            //     });
            // });

            let drawnChart;

            function getPoint(data) {
                // Project SEKAI Championship 2023 Spring rules
                const {combo, perfect, great, good, bad, miss} = data;
                // let point = 0;
                // point += perfect * 3;
                // point += great * 2;
                // point += good * 1;
                // point += bad * 0;
                // point += miss * 0;
                return perfect * 3 + great * 2 + good * 1;
            }
            function getMaxPoint(data) {
                // Project SEKAI Championship 2023 Spring rules
                return data.totalNoteCount * 3;
            }
            function getComboRate(data) {
                return data.combo / data.totalNoteCount;
            }
            function getPerfectRate(data) {
                return data.perfect / data.totalNoteCount;
            }
            function getGreatRate(data) {
                return data.bad / data.totalNoteCount;
            }
            function getGoodRate(data) {
                return data.good / data.totalNoteCount;
            }
            function getBadRate(data) {
                return data.bad / data.totalNoteCount;
            }
            function getMissRate(data) {
                return data.miss / data.totalNoteCount;
            }
            function getCompletenessRate(data) {
                return getPoint(data) / getMaxPoint(data);
            }
            function compareRowData(a, b) {
                if (a.mdid !== b.mdid) {
                    return Math.sign(b.mdid - a.mdid);
                } else if (a.completenessRate !== b.completenessRate) {
                    return Math.sign(b.completenessRate - a.completenessRate);
                } else if (a.perfectRate !== b.perfectRate) {
                    return Math.sign(b.perfectRate - a.perfectRate);
                } else if (a.greatRate !== b.greatRate) {
                    return Math.sign(b.greatRate - a.greatRate);
                } else if (a.goodRate !== b.goodRate) {
                    return Math.sign(b.goodRate - a.goodRate);
                } else if (a.badRate !== b.badRate) {
                    return Math.sign(b.badRate - a.badRate);
                } else if (a.missRate !== b.missRate) {
                    return Math.sign(b.missRate - a.missRate);
                } else {
                    return Math.sign(a.createdAt - b.createdAt);
                }
            }

            function getFilteredMusicDiffs() {
                const levelFilter = recordTabulator.getFilters(true).find(function(item) {
                    return item.field === "playLevel";
                });

                let minLevel = 0;
                let maxLevel = Number.POSITIVE_INFINITY;
                if (levelFilter) {
                    if (!isNaN(parseInt(levelFilter.value.start))) {
                        minLevel = parseInt(levelFilter.value.start);
                    }
                    if (!isNaN(parseInt(levelFilter.value.end))) {
                        maxLevel = parseInt(levelFilter.value.end);
                    }
                }
                return musicDifficulties.filter(function(item) {
                    return item.playLevel >= minLevel && item.playLevel <= maxLevel;
                });
            }

            function getFilteredMusicDiffsPoint() {
                return getFilteredMusicDiffs().reduce(function(prev, curr) {
                    const d = curr.musicDifficulty.toUpperCase();
                    const n = curr.totalNoteCount;
                    prev[d] += n * 3;
                    return prev;
                }, {
                    MASTER: 0,
                    EXPERT: 0,
                    HARD: 0,
                    NORMAL: 0,
                    EASY: 0,
                });
            }

            // 
            // get
            // 

            function getData() {
                return recordTabulator.getRows("active").map(function(row) {
                    const data = convertToData(row.getData());
                    const group = row.getGroup().getKey();
                    return Object.assign(data, {
                        group: group,
                        maxPoint: getMaxPoint(data),
                        point: getPoint(data),
                        comboRate: getComboRate(data),
                        perfectRate: getPerfectRate(data),
                        greatRate: getGreatRate(data),
                        goodRate: getGoodRate(data),
                        badRate: getBadRate(data),
                        missRate: getMissRate(data),
                        completenessRate: getCompletenessRate(data),
                    });
                });
            }
            function getUniqueData() {
                return recordTabulator.getRows("active").map(function(row) {
                    const data = convertToData(row.getData());
                    const group = row.getGroup().getKey();
                    return Object.assign(data, {
                        group: group,
                        maxPoint: getMaxPoint(data),
                        point: getPoint(data),
                        comboRate: getComboRate(data),
                        perfectRate: getPerfectRate(data),
                        greatRate: getGreatRate(data),
                        goodRate: getGoodRate(data),
                        badRate: getBadRate(data),
                        missRate: getMissRate(data),
                        completenessRate: getCompletenessRate(data),
                    });
                }).reduce(function(prev, curr) {
                    const i = prev.findIndex(function(item) {
                        return item.mid === curr.mid;
                    });
                    if (i > -1) {
                        if (compareRowData(prev[i], curr) > 0) {
                            prev[i] = curr;
                        }
                    } else {
                        prev.push(curr);
                    }
                    return prev;
                }, []);
            }
            function getUniqueDiffData() {
                return recordTabulator.getRows("active").map(function(row) {
                    const data = convertToData(row.getData());
                    const group = row.getGroup().getKey();
                    return Object.assign(data, {
                        group: group,
                        maxPoint: getMaxPoint(data),
                        point: getPoint(data),
                        comboRate: getComboRate(data),
                        perfectRate: getPerfectRate(data),
                        greatRate: getGreatRate(data),
                        goodRate: getGoodRate(data),
                        badRate: getBadRate(data),
                        missRate: getMissRate(data),
                        completenessRate: getCompletenessRate(data),
                    });
                }).reduce(function(prev, curr) {
                    const i = prev.findIndex(function(item) {
                        return item.mdid === curr.mdid;
                    });
                    if (i > -1) {
                        if (compareRowData(prev[i], curr) > 0) {
                            prev[i] = curr;
                        }
                    } else {
                        prev.push(curr);
                    }
                    return prev;
                }, []);
            }
            
            // 
            // Grouping
            // 

            function getGroupData() {
                return Object.entries(getData().reduce(function(prev, curr) {
                    if (!prev[curr.group]) {
                        prev[curr.group] = [];
                    }
                    prev[curr.group].push(curr);
                    return prev;
                }, {})).reduce(function(prev, [key, value]) {
                    prev.push({
                        group: key,
                        data: value,
                    });
                    return prev;
                }, []);
            }
            function getUniqueGroupData() {
                return Object.entries(getUniqueData().reduce(function(prev, curr) {
                    if (!prev[curr.group]) {
                        prev[curr.group] = [];
                    }
                    prev[curr.group].push(curr);
                    return prev;
                }, {})).reduce(function(prev, [key, value]) {
                    prev.push({
                        group: key,
                        data: value,
                    });
                    return prev;
                }, []);
            }
            function getUniqueDiffGroupData() {
                return Object.entries(getUniqueDiffData().reduce(function(prev, curr) {
                    if (!prev[curr.group]) {
                        prev[curr.group] = [];
                    }
                    prev[curr.group].push(curr);
                    return prev;
                }, {})).reduce(function(prev, [key, value]) {
                    prev.push({
                        group: key,
                        data: value,
                    });
                    return prev;
                }, []);
            }

            // 
            // Accumulate
            // 

            function getAccumulatedGroupData() {
                return getGroupData().reduce(function(prev, curr, index, array) {
                    const data = array.filter(function(item) {
                        return new Date(item.group).getTime() <= new Date(curr.group).getTime();
                    }).map(function(item) {
                        return item.data;
                    }).reduce(function(_prev, _curr) {
                        return _prev.concat(_curr);
                    }, []);
                    prev.push({
                        group: curr.group,
                        data: data
                    });
                    return prev;
                }, []);
            }
            function getAccumulatedUniqueGroupData() {
                return getUniqueGroupData().reduce(function(prev, curr, index, array) {
                    const data = array.filter(function(item) {
                        return new Date(item.group).getTime() <= new Date(curr.group).getTime();
                    }).map(function(item) {
                        return item.data;
                    }).reduce(function(_prev, _curr) {
                        return _prev.concat(_curr);
                    }, []);
                    prev.push({
                        group: curr.group,
                        data: data
                    });
                    return prev;
                }, []);
            }
            function getAccumulatedUniqueDiffGroupData() {
                return getUniqueDiffGroupData().reduce(function(prev, curr, index, array) {
                    const data = array.filter(function(item) {
                        return new Date(item.group).getTime() <= new Date(curr.group).getTime();
                    }).map(function(item) {
                        return item.data;
                    }).reduce(function(_prev, _curr) {
                        return _prev.concat(_curr);
                    }, []);
                    prev.push({
                        group: curr.group,
                        data: data
                    });
                    return prev;
                }, []);
            }

            // 
            // draw
            // 

            const DIFFICULTY_COLORS = {
                "MASTER": "#9400D3",
                "EXPERT": "#DC143C",
                "HARD": "#FF8C00",
                "NORMAL": "#00CED1",
                "EASY": "#32CD32",
            }

            function drawChart(type, data, options) {
                drawnChart = new Chart(
                    chartCanvas,
                    {
                        type: type,
                        data: data,
                        options: options,
                    }
                )
            }

            function drawPlayCountChart() {
                const data = getGroupData();
                const labels = data.map(x => x.group);
                const datasets = ["MASTER", "EXPERT", "HARD", "NORMAL", "EASY"].map(function(difficulty) {
                    return {
                        label: difficulty,
                        data: data.map(function(item) {
                            const filtered = item.data.filter(function(_item) {
                                return _item.difficulty === difficulty;
                            });
                            return filtered.length
                        }),
                        fill: false,
                        borderColor: DIFFICULTY_COLORS[difficulty],
                        pointBackgroundColor: DIFFICULTY_COLORS[difficulty],
                        tension: 0,
                        radius: 0,
                    }
                })
                
                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets,
                    },
                    {
                        scales: {
                            x: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawPlayCountAccChart(acc) {
                const data = getAccumulatedGroupData();
                const labels = data.map(x => x.group);
                const datasets = ["MASTER", "EXPERT", "HARD", "NORMAL", "EASY"].map(function(difficulty) {
                    return {
                        label: difficulty,
                        data: data.map(function(item) {
                            const filtered = item.data.filter(function(_item) {
                                return _item.difficulty === difficulty;
                            });
                            return filtered.length;
                        }),
                        fill: false,
                        borderColor: DIFFICULTY_COLORS[difficulty],
                        pointBackgroundColor: DIFFICULTY_COLORS[difficulty],
                        tension: 0,
                        radius: 0,
                    }
                })

                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        scales: {
                            x: {
                                display: false
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawCompletenessRateChart() {
                const data = getAccumulatedUniqueDiffGroupData();
                const max = getFilteredMusicDiffsPoint();
                const labels = data.map(x => x.group);
                const datasets = ["MASTER", "EXPERT", "HARD", "NORMAL", "EASY"].map(function(difficulty) {
                    return {
                        label: difficulty,
                        data: data.map(function(item) {
                            const filtered = item.data.filter(function(_item) {
                                return _item.difficulty === difficulty;
                            });

                            return Math.round(filtered.reduce(function(p, c) {
                                return p + c.point;
                            }, 0) / max[difficulty] * 10000) / 100;
                        }),
                        fill: false,
                        borderColor: DIFFICULTY_COLORS[difficulty],
                        pointBackgroundColor: DIFFICULTY_COLORS[difficulty],
                        tension: 0,
                        radius: 0,
                    }
                })

                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                min: 0,
                                max: 100
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawClearCountChart() {
                const data = getAccumulatedUniqueGroupData();
                const maxLen = musics.length;
                const labels = data.map(x => x.group);
                const datasets = [{
                    data: data.map(function(item) {
                        return item.data.length;
                    }),
                    fill: true,
                    borderColor: "#9400D3",
                    pointBackgroundColor: "#9400D3",
                    tension: 0,
                    radius: 0,
                }];

                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                min: 0,
                                max: maxLen
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawClearConditionCountChart() {
                const data = getUniqueData();
                const maxLen = musics.length;
                let clearedLen = 0;
                const labels = ["ALL PERFECT", "FULL COMBO", "LIVE CLEAR", "NOT PLAYED"];
                const colors = ["#9400D3", "#ffa9cc", "#d4a3b7", "#bbbbbb"];
                const datasets = [{
                    label: "Musics",
                    data: labels.map(function(cond, i) {
                        if (i < labels.length - 1) {
                            const filtered = data.filter(function(item) {
                                return item.condition === cond;
                            });

                            clearedLen += filtered.length;

                            return filtered.length;
                        } else {
                            return maxLen - clearedLen;
                        }
                    }),
                    backgroundColor: colors,
                    hoverOffset: 64,
                    borderWidth: 0,
                }]

                drawChart(
                    "pie",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        responsive: true,
                        maintainAspectRatio: false,
                    }
                )
            }

            function drawComboCountChart() {
                const data = getGroupData();
                const types = ["perfect", "great", "good", "bad", "miss"];
                const colors = ["#9400D3", "#DC143C", "#32CD32", "#00CED1", "#bbbbbb"];
                const labels = data.map(x => x.group);
                const datasets = types.map(function(type, i) {
                    const color = colors[i];
                    const label = type.toUpperCase();
                    return {
                        label: label,
                        data: data.map(function(item) {
                            return item.data.reduce(function(p, c) {
                                return p + c[type];
                            }, 0);
                        }),
                        fill: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        tension: 0,
                        radius: 0,
                    }
                });
                
                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        scales: {
                            x: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawConditionCountChart() {
                const data = getGroupData();
                const types = ["ALL PERFECT", "FULL COMBO", "LIVE CLEAR"];
                const colors = ["#9400D3", "#ffa9cc", "#bbbbbb"];
                const labels = data.map(x => x.group);
                const datasets = types.map(function(type, i) {
                    const color = colors[i];
                    const label = type.toUpperCase();
                    return {
                        label: label,
                        data: data.map(function(item) {
                            return item.data.filter(function(_item) {
                                return _item.condition === type;
                            }).length;
                        }),
                        fill: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        tension: 0,
                        radius: 0,
                    }
                });
                
                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        scales: {
                            x: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            function drawConditionCountAccChart() {
                const data = getAccumulatedGroupData();
                const types = ["ALL PERFECT", "FULL COMBO", "LIVE CLEAR"];
                const colors = ["#9400D3", "#ffa9cc", "#bbbbbb"];
                const labels = data.map(x => x.group);
                const datasets = types.map(function(type, i) {
                    const color = colors[i];
                    const label = type.toUpperCase();
                    return {
                        label: label,
                        data: data.map(function(item) {
                            return item.data.filter(function(_item) {
                                return _item.condition === type;
                            }).length;
                        }),
                        fill: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        tension: 0,
                        radius: 0,
                    }
                });
                
                drawChart(
                    "line",
                    {
                        labels: labels, // x
                        datasets: datasets
                    },
                    {
                        scales: {
                            x: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'nearest',
                            axis: "xy"
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                    },
                )
            }

            
            // 
            // animation
            // 

            function getLineAnimation(data, delay) {
                const totalDuration = delay || 10000;
                const delayBetweenPoints = totalDuration / data.length;
                const previousY = (ctx) => ctx.index === 0 ? ctx.chart.scales.y.getPixelForValue(100) : ctx.chart.getDatasetMeta(ctx.datasetIndex).data[ctx.index - 1].getProps(['y'], true).y;
                return {
                    x: {
                        type: 'number',
                        easing: 'linear',
                        duration: delayBetweenPoints,
                        from: NaN, // the point is initially skipped
                        delay(ctx) {
                        if (ctx.type !== 'data' || ctx.xStarted) {
                            return 0;
                        }
                        ctx.xStarted = true;
                        return ctx.index * delayBetweenPoints;
                        }
                    },
                    y: {
                        type: 'number',
                        easing: 'linear',
                        duration: delayBetweenPoints,
                        from: previousY,
                        delay(ctx) {
                        if (ctx.type !== 'data' || ctx.yStarted) {
                            return 0;
                        }
                        ctx.yStarted = true;
                        return ctx.index * delayBetweenPoints;
                        }
                    }
                };
            }

            // 
            // handler
            // 

            function chartDrawHandler(e) {
                startEvent();

                if (drawnChart) {
                    drawnChart.destroy();
                }
                const type = chartDrawType.value;

                // check values
                for (const item of recordTabulator.getData()) {
                    if (!isValidData(item)) {
                        alert("Invalid data found.");
                        endEvent();
                        return false;
                    }
                }

                switch(type) {
                    case "play-count": drawPlayCountChart(); break;
                    case "play-count-acc": drawPlayCountAccChart(true); break;
                    case "completeness": drawCompletenessRateChart(); break; // by point
                    case "clear-count": drawClearCountChart(); break;
                    case "clear-condition-count": drawClearConditionCountChart(); break;
                    case "combo-count": drawComboCountChart(); break;
                    case "condition-count": drawConditionCountChart(); break;
                    case "condition-count-acc": drawConditionCountAccChart(); break;
                }

                endEvent();

                window.scrollTo(0, document.body.scrollHeight   );
            }

            chartDrawButton.addEventListener("click", chartDrawHandler);
        })();
        
    </script>
</body>

</html>